The following stuff is the code extracted from jacobian.mw.  Each line is
preceded by a tab character (that isn't actually present in the code).  Each
input group (or whatever the correct term is in maple) is additionally
preceded by a label of the form "Ln>".

L3>	restart: Digits:=100; maxp:=61;
L4>	Digits := 100;
L5>	jacobi:=(p,a,b)->simplify(JacobiP(p,a,b,x),'JacobiP');
L6>	A:=(n,a,b)->GAMMA(2*n+a+b+1)/(2^n*n!*GAMMA(n+a+b+1));
L7>	gamma_n:=(n,a,b)->1/(2^(2*n)*(n!)^2)*(2^(2*n+a+b+1)*n!)/(2*n+a+b+1)*(GAMMA(n+a+1)*GAMMA(n+b+1))/(GAMMA(n+a+b+1)) ;
L8>	weight:=(n,a,b,xx)->A(n,a,b)/A(n-1,a,b)*gamma_n(n-1,a,b)/JacobiP(n-1,a,b,xx)/subs(X=xx,diff(JacobiP(n,a,b,X),X));
L9>	quad:=proc(file,name,alpha,beta,maxp)
	local i,N,n,points,p,w,fd;
	fd := fopen(file, WRITE);
	fprintf(fd,"// -*-c++-*-
	// WARNING
	// This file is automatically generated by jacobian.mw! Don't edit by hand!
	
	#ifndef DUNE_INCLUDING_IMPLEMENTATION
	#error This is a private header that should not be included directly.
	#error Use #include <dune/geometry/quadraturerules.hh> instead.
	#endif
	#undef DUNE_INCLUDING_IMPLEMENTATION
	
	namespace Dune {
	  
	  // for fundamental types
	  template<typename ct>
	  void %sQuadratureInitHelper<ct,true>::init(int p,
	         std::vector< FieldVector<ct, 1> > & _points,
	         std::vector< ct > & _weight,
	         int & delivered_order)
	  {
	    switch(p)
	    {
	",name);
	for i from 1 to maxp/2+1 do
	  fprintf(fd,"    // order %d,%d\n    case %d:\n    case %d:\n", 2*i-2,2*i-1, 2*i-2,2*i-1);
	  points := fsolve(jacobi(i,alpha,beta)):
	  if i=1 then points:=array([points]): end if:
	  N:=0:
	  for p in points do N:=N+1: end do:
	  fprintf(fd,"      delivered_order = %d;\n",2*i-1);
	  fprintf(fd,"      _points.resize(%d);\n",N);
	  fprintf(fd,"      _weight.resize(%d);\n",N);
	  n:=0:
	  for n from 1 to N do
	    p:=points[n]:
	    fprintf(fd,"      _points[%d] = %a;\n",n-1,p/2+0.5);
	    w:=evalf(weight(i,alpha,beta,p));
	    fprintf(fd,"      _weight[%d] = %a;\n",n-1,w/2);
	  end do:
	  fprintf(fd,"      break;\n\n");
	end do:
	fprintf(fd,"    default:
	      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
	    }
	  }
	
	  // for non-fundamental types: assign numbers as strings
	  template<typename ct>
	  void %sQuadratureInitHelper<ct,false>::init(int p,
	         std::vector< FieldVector<ct, 1> > & _points,
	         std::vector< ct > & _weight,
	         int & delivered_order)
	  {
	    switch(p)
	    {
	",name);
	for i from 1 to maxp/2+1 do
	  fprintf(fd,"    // order %d,%d\n    case %d:\n    case %d:\n", 2*i-2,2*i-1, 2*i-2,2*i-1);
	  points := fsolve(jacobi(i,alpha,beta)):
	  if i=1 then points:=array([points]): end if:
	  N:=0:
	  for p in points do N:=N+1: end do:
	  fprintf(fd,"      delivered_order = %d;\n",2*i-1);
	  fprintf(fd,"      _points.resize(%d);\n",N);
	  fprintf(fd,"      _weight.resize(%d);\n",N);
	  n:=0:
	  for n from 1 to N do
	    p:=points[n]:
	    fprintf(fd,"      _points[%d] = \"%a\";\n",n-1,p/2+0.5);
	    w:=evalf(weight(i,alpha,beta,p));
	    fprintf(fd,"      _weight[%d] = \"%a\";\n",n-1,w/2);
	  end do:
	  fprintf(fd,"      break;\n\n");
	end do:
	fprintf(fd,"    default:
	      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
	    }
	  }
	
	} // namespace
	");
	fclose(fd);
	end proc:
L10>	quad("jacobi_1_0_imp.hh","Jacobi1",1,0,maxp);
L11>	quad("jacobi_2_0_imp.hh","Jacobi2",2,0,maxp);
L12>	quad("cube_imp.hh","Cube",0,0,maxp);
L13>	
