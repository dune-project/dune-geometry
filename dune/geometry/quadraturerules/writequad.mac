load(to_poly_solve)$

epsilon: 1e-110$

write_quad(file, name, scriptname, polynome_fnkt, weight_fnkt, maxp) :=
block([i,N,n_,points,p,w,fd],
fd: openw(file),
printf(fd, "// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
//
// WARNING
// This file is automatically generated by ~a! Don't edit by hand!

#ifndef DUNE_INCLUDING_IMPLEMENTATION
#error This is a private header that should not be included directly.
#error Use #include <dune/geometry/quadraturerules.hh> instead.
#endif
#undef DUNE_INCLUDING_IMPLEMENTATION

namespace Dune {

  // for fundamental types
  template<typename ct>
  void ~aQuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
", scriptname, name),
for i: 1 thru maxp/2+1 do block([],
  printf(fd,"    // order ~d,~d
    case ~d :
    case ~d :
", 2*i-2,2*i-1, 2*i-2,2*i-1),
  points: makelist(rhs(p), p, bfallroots(polynome_fnkt(i))),
  weights: makelist(bfloat(weight_fnkt(i, p)), p, points),
  N: length(points),
  S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
  printf(fd,"      delivered_order = ~d;
",2*i-1),
  printf(fd,"      _points.resize(~d);
",N),
  printf(fd,"      _weight.resize(~d);
",N),
  for n_: 1 thru N do block([n],
    n: S[n_],
    p: (points[n]+1)/2,
    p: max(p-epsilon,-epsilon)+epsilon,
    w: weights[n]/2,
    printf(fd,"      _points[~d] = ~h;
",n_-1, p),
    printf(fd,"      _weight[~d] = ~h;
",n_-1, w)
  ),
  printf(fd,"      break;

")
),

printf(fd,"    default :
      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }

  // for non-fundamental types: assign numbers as strings
  template<typename ct>
  void ~aQuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
",name),

for i: 1 thru maxp/2+1 do block([],
  printf(fd,"    // order ~d,~d
    case ~d :
    case ~d :
", 2*i-2,2*i-1, 2*i-2,2*i-1),
  points: makelist(rhs(p), p, bfallroots(polynome_fnkt(i))),
  weights: makelist(bfloat(weight_fnkt(i,p)), p, points),
  N: length(points),
  S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
  printf(fd,"      delivered_order = ~d;
",2*i-1),
  printf(fd,"      _points.resize(~d);
",N),
  printf(fd,"      _weight.resize(~d);
",N),
  for n_: 1 thru N do block([n],
    n: S[n_],
    p: (points[n]+1)/2,
    p: max(p-epsilon,-epsilon)+epsilon,
    w: weights[n]/2,
    printf(fd,"      _points[~d] = ct(\"~h\");
",n_-1,p),
    printf(fd,"      _weight[~d] = ct(\"~h\");
",n_-1,w)
  ),
  printf(fd,"      break;

")
),

printf(fd,"    default :
      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }

} // namespace
"),
close(fd)
)$
